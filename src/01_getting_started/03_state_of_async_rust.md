# 비동기 Rust의 상태

비동기 Rust 중 어떤 부분은 동기 Rust와 동일한 수준의 안정성이 보장됩니다. 다른 부분은 여전히 발전하고 있으며 시간에 따라 변화가 있을 것입니다. 비동기 Rust를 이용하면 아래의 항목들을 기대할 수 있습니다. 

- 일반적인 동시성 작업에 대한 뛰어난 런타임 성능
- 라이프타임과 피닝과 같은 고급 언어 기능과 더 잦은 상호작용
- 동기와 비동기 간 그리고 서로 다른 비동기 런타임 간의 일부 호환성 제약
- 비동기 런타임 및 언어 지원의 지속적인 발전으로 인한 높은 유지보수 부담

즉, 비동기 Rust는 사용하기가 더 어렵고 동기 Rust보다 유지보수 부담이 더 크지만 그 대가로 동급 최고의 성능을 제공합니다. 비동기 Rust의 모든 영역은 지속적으로 개선되기 때문에 이런 문제들에 따른 영향은 점차 사라질 것입니다.

## 언어 및 라이브러리 지원

비동기 프로그래밍은 Rust 자체에서 지원하지만 대부분의 비동기 응용프로그램들은 커뮤니티에서 만든 크레이트의 기능에 의존합니다.
따라서 사용자는 언어 기능과 라이브러리 지원 모두를 사용해야 합니다.

- [`Future`](https://doc.rust-lang.org/std/future/trait.Future.html) 트레잇같이 가장 기초적인 트레잇, 타입, 함수들은 표준 라이브러리에서 지원
- `async/await` 문법은 러스트 컴파일러에서 바로 지원
- 다양한 유틸리티 타입, 매크로, 함수들은 [`futures`](https://docs.rs/futures/) 크레이트에서 지원하며 모든 비동기 Rust 응용프로그램에서 이용 가능
- 비동기 코드, IO, 태스크 생성은 Tokio, async-std같은 "비동기 런타임"에서 제공하며 대부분의 비동기 응용프로그램과 일부 비동기 크레이트는 특정한 런타임을 이용. 자세한 사항은 ["비동기 생태계"](../08_ecosystem/00_chapter.md) 참조.

동기 Rust에서 사용할 수 있는 일부 언어 기능은 아직 비동기 Rust에서 사용할 수 없습니다. 특히 Rust는 트레잇에서 비동기 함수를 선언할 수 없습니다. 동일한 결과를 얻기 위해서는 좀 더 긴 코드를 작성해야 합니다.

## 컴파일과 디버깅

대부분의 경우 비동기 Rust의 컴파일러 및 런타임 오류는 Rust에서와 마찬가지로 작동합니다. 몇 가지 주목할만한 차이점만 알면 됩니다.

### 컴파일 오류

비동기 Rust의 컴파일 오류는 동기 Rust와 같은 높은 수준의 규정을 준수하지만 비동기 Rust가 종종 라이프타임 및 피닝같은 더 복잡한 언어 기능에 의존하기 때문에 컴파일 오류를 좀 더 자주 만나게 될 수도 있습니다.

### 런타임 오류

컴파일러는 비동기 함수와 만날 때마다 상태 머신을 내부에 생성합니다. 비동기 Rust의 스택 추적에는 일반적으로 상태 머신의 세부 정보와 런타임의 함수 호출 내역이 포함됩니다. 따라서 스택 추적을 해석하는 것이 동기 Rust보다 약간 더 복잡할 수도 있습니다.

### 새로운 오류 모드

비동기 Rust에서는 몇 가지 새로운 오류 모드가 생길 수 있습니다. 예를 들어 비동기 컨텍스트에서 차단된 함수를 호출하거나 `Future` 트레잇을 잘못 구현하는 경우가 있겠죠. 이런 오류들은 컴파일러나 때로는 유닛 테스트에 모두 자동으로 전달할 수 있습니다. 이 문서에서 제공하고자 하는 기본 개념을 확실히 이해하면 이런 함정들을 피할 수 있을 것입니다.

## 호환성 고려사항

비동기와 동기 코드를 항상 자유롭게 결합할 수는 없습니다. 예를 들어 동기 함수 내에서 비동기 함수를 바로 호출할 수는 없습니다. 동기와 비동기 코드는 다른 디자인 패턴으로 나오는 경향이 있어서 다양한 환경에 맞게 코드를 합성하기가 어려워질 수도 있습니다.

비동기 코드조차도 항상 자유롭게 결합할 수는 없습니다. 어떤 크레이트들은 특정 비동기 런타임에 의존합니다. 이 경우에는 해당 크레이트의 의존성 목록에 해당 런타임을 특정합니다.

이런 호환성 문제들은 선택지를 제한하기 때문에 어떤 비동기 런타임과 어떤 크레이트들이 필요한 지를 초기에 조사해야 합니다. 특정 런타임에 정착한 뒤에는 호환성에 대해서 걱정할 필요가 없습니다.

## 성능 특성

비동기에 따른 CPU와 메모리 상의 추가비용은 보통 OS 스레드를 바로 사용하는 것보다 현저하게 낮습니다. 특히 서버와 같이 많은 양의 IO 바인딩 작업이 있는 경우에 특히 그렇습니다. Rust의 무비용 추상화와 함께 하기 떄문에 비동기 Rust는 가장 성능이 뛰어난 동시성 환경 중 하나입니다. 비동기 런타임을 선택하는 것에 따라 성능 특성이 영향을 받지만 미미합니다.

 단, 비동기 Rust는 비동기 함수에서 생성하는 상태 머신과 각 실행파일이 비동기 런타임을 포함해야 하는 점 때문에 바이너리가 더 크게 나올 수도 있습니다. 또한 기존 비동기 런타임은 레이턴시에 민감한 응용프로그램에서 필요할 수 있는 작업수행일정 정밀조정 기능을 지원하지 않습니다. 
