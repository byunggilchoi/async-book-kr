# 왜 비동기를 사용할까요?

우리 모두는 Rust가 빠르고 안전하게 소프트웨어를 작성하게 해주는 방식을 좋아합니다. 그런데 왜 비동기로 코드를 작성할까요?

비동기 코드를 사용하면 동일한 OS 스레드에서 여러 작업을 동시에 수행할 수 있습니다. 스레드를 이용하는 일반적인 응용프로그램에서 두 개의 서로 다른 웹페이지를 다운로드하려는 경우 다음과 같이 두 개의 서로 다른 스레드에 작업을 분산합니다.

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites}}
```

많은 응용프로그램에서 이 작업은 잘 작동하며 스레드도 한 번에 여러 개의 다른 작업을 실행하도록 설계되어 있습니다. 하지만 몇 가지 제한도 발생합니다. 서로 다른 스레드를 전환하고 스레드 간에 데이터를 공유하는 과정에서 많은 비용이 발생하는 것입니다. 스레드가 그냥 앉아서 아무 것도 하지 않더라도 귀한 시스템 자원을 사용하기 때문입니다. 비동기 코드는 이런 비용을 제거하기 위해서 설계되었습니다. 위에 나오는 함수를 Rust의 `async`/`.await` 표기를 이용하여 아래와 같이 재작성할 수 있습니다. 그러면 여러 스레드를 만들지 않고도 여러 작업을 처리할 수 있게 됩니다.

```rust,ignore
{{#include ../../examples/01_02_why_async/src/lib.rs:get_two_sites_async}}
```

비동기 응용프로그램은 대체로 스레드를 생성하는 구현보다 훨씬 빠르고 자원을 적게 사용합니다. 그래도 비용은 있습니다. 스레드는 OS 단계에서 지원하기 때문에 특별한 프로그래밍 모델이 필요하지 않습니다. 어떤 함수도 스레드를 생성할 수 있으며 스레드를 사용하는 함수를 호출하는 것은 보통 일반 함수를 호출하는 것만큼 쉽습니다. 하지만 비동기 함수에는 언어 혹은 라이브러리 차원의 특별한 지원이 필요합니다.
Rust에서 `async fn`은 `Future`를 반환하는 비동기 함수를 생성합니다. 함수의 본문을 실행하려면 반환된 `Future`를 먼저 실행해야 합니다.

전통적인 스레드 방식의 응용프로그램도 꽤 효과적일 수 있다는 점과 메모리를 적게 쓰고 예측 가능한 Rust의 특징은 `async`를 사용하지 않고도 많은 일을 할 수 있다는 점을 꼭 기억하세요. 비동기 프로그래밍 모델은 더 복잡하기 때문에 항상 그만한 가치가 있는 것은 아닙니다. 더 간단한 스레드 모델을 사용해서 응용프로그램이 잘 만들어질 수 있는지를 고려해보는 것도 중요합니다.